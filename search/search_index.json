{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#lifter-api","title":"Lifter API","text":""},{"location":"#lifter-api-documentation","title":"Lifter API Documentation","text":"<p>Did you mean Lifter API Wrapper Documentation?</p>"},{"location":"#hosting","title":"Hosting","text":"<p>This is hosted on Digital Ocean's App Platform. Code changes to this repository on the main branch will automatically trigger changes to the live web application.</p> <p>The backend API and the frontend are set up on their own apps. And there is set up required (see below). Normally, this is first time.</p>"},{"location":"#setting-up-the-backend","title":"Setting up the Backend","text":""},{"location":"#1-run-command","title":"1. Run command","text":"<p>This is the run command:</p> <pre><code>\ngunicorn --worker-tmp-dir /dev/shm config.wsgi\n\n</code></pre> <p>Note the <code>config.wsgi</code></p>"},{"location":"#2-api-domain","title":"2. API Domain","text":"<p>Ensure the domain provided this is set to: <code>https://api.lifter.shivan.xyz</code>.</p> <p>This may take time to configure. And this is all handled by Digital Ocean.</p>"},{"location":"#3-backend-environment-variables","title":"3. Backend Environment Variables","text":"<p>The following environment variables should be set:</p> <pre><code>DJANGO_DEVELOPMENT = 0\nALLOWED_HOSTS = ${APP_DOMAIN}\nDATABASE_URL = ${db.DATABASE_URL}\nCORS_ALLOWED_ORIGINS = https://lifter.shivan.xyz\nSECRET_KEY = &lt;see below&gt;\nHASHID_FIELD_SALT = &lt;see below&gt;\nSENTRY_DSN_1 = &lt;see below&gt;\nSENTRY_DSN_2 = &lt;see below&gt;\nSENTRY_SAMPLE_RATE = 1.0 # depends\n</code></pre>"},{"location":"#secret-keys","title":"Secret Keys","text":"<p>Running the below code will provide the a random hash to set <code>SECRET_KEY</code> and <code>HASHID_FIELD_SALT</code>.</p> <pre><code>\n$ make generate-key\n\nffqd6(a-&amp;dqk#znv!4@!1u=&amp;_et9b^wdgpm5cz4=^b=9_3xaux\n\n</code></pre> <p>Tip: Use <code>make generate-key | pbcopy</code> on MacOS if you want to copy the key to clipboard.</p>"},{"location":"#sentry-environment-variables","title":"Sentry Environment Variables","text":"<p>These are mapped accordingly:</p> <pre><code>sentry_sdk.init(\n    dsn=f\"https://{SENTRY_DSN_1}.ingest.sentry.io/{SENTRY_DSN_2}\",\n    integrations=[\n        DjangoIntegration(),\n    ],\n    # set this to between 0 and 1.0 when in production\n    trace_sample_rate=SENTRY_SAMPLE_RATE\n</code></pre>"},{"location":"#4-migrations-and-superuser","title":"4. Migrations and Superuser","text":"<p>In the console of the Digital Ocean App Platform migrations and a creation of a superuser is required.</p> <p>Migration:</p> <pre><code>python manage.py makemigrations\npython manage.py migrate\n</code></pre> <p>Create superuser:</p> <pre><code>python manage.py createsuperuser\n</code></pre>"},{"location":"#5-debugging","title":"5. Debugging","text":"<p>There is a <code>debug.log</code> file provided.</p> <p>Use this command to follow the debug log in realtime:</p> <pre><code>tail -f debug.log\n</code></pre>"},{"location":"#setting-up-the-frontend","title":"Setting up the Frontend","text":""},{"location":"#1-catch-all","title":"1. Catch-all","text":"<p>Catch-all needs to be set to <code>index.html</code>. This is because <code>react-router</code> uses the url link to decide what content to serve, rather than a url requesting something on the server. That means a url other than the root url will return a 404 error.</p> <p>A catch-all will return the root url for processing by javascript.</p>"},{"location":"#2-main-domain","title":"2. Main Domain","text":"<p>Another domain is provided. Ensure this is set to: <code>https://lifter.shivan.xyz</code>.</p> <p>This takes time and is all handled by Digital Ocean.</p>"},{"location":"#3-frontend-environment-variables","title":"3. Frontend Environment Variables","text":"<p>The environment variables need to be set:</p> <pre><code>REACT_APP_API_URL = \"https://api.lifter.shivan.xyz/v1\"\n</code></pre>"},{"location":"#local-development","title":"Local Development","text":"<p>Base requirements include:</p> <ul> <li>Docker v20.10.8</li> <li>Docker Compose v2.0.0</li> <li>Node v16.14.2</li> <li>Python v3.10.0</li> </ul> <p>Here is the rough layout of the application:</p> <pre><code>lifter-api\n\u251c\u2500\u2500 backend/\n\u2502   \u251c\u2500\u2500 ... Django Rest Framework stuff\n\u251c\u2500\u2500 frontend\n\u2502   \u251c\u2500\u2500 ... React Typescript TailwindCSS stuff\n\u2514\u2500\u2500 ...other files\n</code></pre> <p>The PostgreSQL database runs in a docker container and to start the API all you need to do is run:</p> <pre><code>make run\n</code></pre> <p>You might have to perform migrations:</p> <pre><code>make migrations\n</code></pre> <p>There is an API backend as well as a nice looking frontend layout.</p> <p>To run the frontend:</p> <pre><code>make run-frontend\n</code></pre>"},{"location":"#lifter-api-wrapper","title":"Lifter API Wrapper","text":"<p>Here is an API wrapper implementation to allow ease of use with the RESTful framework.</p> <p>It is also available on PyPI.</p> <p>You can easily install it:</p> <pre><code>\npip install lifter-api-wrapper\n\n</code></pre>"},{"location":"about/","title":"About","text":"<p>The goal of Lifter API is to make Weightlifting Competition results more accessible.</p> <p>The origin story goes, we were tired of viewing competition results on .pdf and Excel files.</p> <p>It was also difficult to determine records, and gradings.</p>"},{"location":"grading/","title":"Grading","text":""},{"location":"grading/#how-it-works","title":"How it works","text":"<p>Grading is determined based on looking at a dictionary.</p> <p>The grade is applied to a lift. The athlete is awarded if they have achieved the total for the current year.</p> <p>This is represented as a badge.</p> <p>Determine grade for a lift.</p>"},{"location":"grading/#api.models.utils.grading.determine_grade","title":"<code>determine_grade(total_lifted, weight_category)</code>","text":"<p>Provide the grade for a particular lift.</p> <p>Parameters:</p> Name Type Description Default <code>total_lifted</code> <code>int</code> <p>The total lifted.</p> required <code>weight_category</code> <code>str</code> <p>The weight class for the athlete.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The grade.</p> Source code in <code>api/models/utils/grading.py</code> <pre><code>def determine_grade(total_lifted: int, weight_category: str) -&gt; str:\n\"\"\"Provide the grade for a particular lift.\n\n    Args:\n        total_lifted (int): The total lifted.\n        weight_category (str): The weight class for the athlete.\n\n    Returns:\n        (str): The grade.\n    \"\"\"\n    grades = STANDARDS.get(weight_category)\n    if grades is not None:\n        for k, v in grades.items():\n            if v is not None and total_lifted &gt;= v:\n                return k.title()\n    return None\n</code></pre>"},{"location":"grading/#future","title":"Future","text":"<p>The plan is to store the grades on a database, linking to weight catetory and setting a era in case they change from year to year.</p>"},{"location":"how/","title":"How It Works","text":""},{"location":"how/#overview","title":"Overview","text":"<p>The API consists of three models: <code>Athlete</code>, <code>Competition</code>, and <code>Lift</code></p>"},{"location":"how/#determining-the-junioryouthsenior","title":"Determining the Junior/Youth/Senior","text":"<p>The API is able to determine if a athlete at the time of the competition date start if they are Youth, Junior and/or Senior.</p>"},{"location":"how/#design-choices","title":"Design choices","text":""},{"location":"how/#female-before-male-ordering","title":"Female before Male ordering","text":"<p>Generally, competitions lift with female first following by males.</p> <p>The subject of gender can be particularly sensitive. So a choice was made to detach gender from athletes, and instead</p>"},{"location":"how/#data-protection","title":"Data Protection","text":"<p>The only data available is the athlete's name, birth year (to determine age grading) and their competitions lifts.</p>"},{"location":"how/#grading","title":"Grading","text":"<p>Grading is determined by looking at the lifts for the current year and determining the best grade from these lifts.</p>"},{"location":"how/#roadmap","title":"Roadmap","text":"<ul> <li>Include volunteers on the competition results</li> </ul>"},{"location":"placing/","title":"Placing","text":"<p>Determining placing (i.e. 1st, 2nd, 3rd) in weightlifting is handed by a property on the lift model.</p> <p>According to the IWF rules (pls find source), the athlete who achieves the highest total first in placed ahead.</p> <p>Essentially it is a sort of different values for athletes in a competition, filtering on category:</p> <ol> <li>Highest total</li> <li>Lowest clean and jerk</li> <li>Lowest lottery number.</li> </ol> <p>         Bases: <code>models.Model</code></p> <p>Lift model.</p> Source code in <code>api/models/lifts.py</code> <pre><code>class Lift(models.Model):\n\"\"\"Lift model.\"\"\"\n\n    # key fields\n    reference_id = HashidAutoField(\n        primary_key=True, salt=f\"liftmodel_reference_id_{HASHID_FIELD_SALT}\"\n    )\n    competition = models.ForeignKey(\n        \"api.Competition\", on_delete=models.CASCADE\n    )\n    athlete = models.ForeignKey(\"api.Athlete\", on_delete=models.CASCADE)\n\n    # other fields\n    session_number = models.IntegerField(null=True)\n    lottery_number = models.IntegerField(blank=True)\n    bodyweight = models.DecimalField(\n        blank=True, max_digits=5, decimal_places=2\n    )\n    weight_category = models.CharField(\n        max_length=5, choices=ALL_WEIGHT_CATEGORIES, blank=True\n    )\n    # TODO: if `team` is \"GUEST\", then lifter is a guest\n    team = models.CharField(max_length=128, blank=True, default=\"IND\")\n\n    # lifts fields\n    # snatches\n    snatch_first = models.CharField(\n        max_length=6,\n        choices=LIFT_STATUS,\n        blank=True,\n        default=DEFAULT_LIFT_STATUS,\n    )\n    snatch_first_weight = models.IntegerField(blank=True, default=0)\n    snatch_second = models.CharField(\n        max_length=6,\n        choices=LIFT_STATUS,\n        blank=True,\n        default=DEFAULT_LIFT_STATUS,\n    )\n    snatch_second_weight = models.IntegerField(blank=True, default=0)\n    snatch_third = models.CharField(\n        max_length=6,\n        choices=LIFT_STATUS,\n        blank=True,\n        default=DEFAULT_LIFT_STATUS,\n    )\n    snatch_third_weight = models.IntegerField(blank=True, default=0)\n\n    # cnj\n    cnj_first = models.CharField(\n        max_length=6,\n        choices=LIFT_STATUS,\n        blank=True,\n        default=DEFAULT_LIFT_STATUS,\n    )\n    cnj_first_weight = models.IntegerField(blank=True, default=0)\n    cnj_second = models.CharField(\n        max_length=6,\n        choices=LIFT_STATUS,\n        blank=True,\n        default=DEFAULT_LIFT_STATUS,\n    )\n    cnj_second_weight = models.IntegerField(blank=True, default=0)\n    cnj_third = models.CharField(\n        max_length=6,\n        choices=LIFT_STATUS,\n        blank=True,\n        default=DEFAULT_LIFT_STATUS,\n    )\n    cnj_third_weight = models.IntegerField(blank=True, default=0)\n\n    history = AuditlogHistoryField(pk_indexable=False)\n    history_record = HistoricalRecords(\n        history_id_field=HashidAutoField(\n            salt=f\"lift_history_id_{HASHID_FIELD_SALT}\"\n        )\n    )\n\n    objects = LiftManager()\n\n    class Meta:\n        ordering = [\"weight_category\", \"lottery_number\"]\n        constraints = [\n            models.UniqueConstraint(\n                fields=[\"competition\", \"lottery_number\", \"weight_category\"],\n                name=\"session_lottery_unique_combination\",\n            ),\n            models.UniqueConstraint(\n                fields=[\"competition\", \"athlete\"],\n                name=\"competition_athlete_unique_combination\",\n            ),\n        ]\n\n    #\n    # custom fields\n    #\n    # lifts\n    #\n    @property\n    def snatches(self) -&gt; dict[str, LiftT]:\n\"\"\"Snatches custom field.\"\"\"\n        return {\n            \"1st\": {\n                \"lift_status\": self.snatch_first,\n                \"weight\": self.snatch_first_weight,\n            },\n            \"2nd\": {\n                \"lift_status\": self.snatch_second,\n                \"weight\": self.snatch_second_weight,\n            },\n            \"3rd\": {\n                \"lift_status\": self.snatch_third,\n                \"weight\": self.snatch_third_weight,\n            },\n        }\n\n    # @property\n    # def new_snatch_first(self) -&gt; int | None:\n    #     if self.snatch_first == \"DNA\":\n    #         return None\n    #     elif self.snatch_first == \"NOLIFT\":\n    #         return -1 * abs(self.snatch_first_weight)\n    #     elif self.snatch_first == \"LIFT\":\n    #         return abs(self.snatch_first_weight)\n\n    @property\n    def cnjs(self) -&gt; dict[str, LiftT]:\n\"\"\"Clean and Jerk custom field.\"\"\"\n        return {\n            \"1st\": {\n                \"lift_status\": self.cnj_first,\n                \"weight\": self.cnj_first_weight,\n            },\n            \"2nd\": {\n                \"lift_status\": self.cnj_second,\n                \"weight\": self.cnj_second_weight,\n            },\n            \"3rd\": {\n                \"lift_status\": self.cnj_third,\n                \"weight\": self.cnj_third_weight,\n            },\n        }\n\n    @property\n    def best_snatch_weight(self) -&gt; tuple[str, int]:\n\"\"\"Best snatch weight returned.\"\"\"\n        return best_lift(self.snatches)\n\n    @property\n    def best_cnj_weight(self) -&gt; tuple[str, int]:\n\"\"\"Best clean and jerk returned.\"\"\"\n        return best_lift(self.cnjs)\n\n    @property\n    def total_lifted(self) -&gt; int:\n\"\"\"Calculate total.\"\"\"\n        total_lifted = 0\n        snatch_lifts = [\n            self.snatch_first,\n            self.snatch_second,\n            self.snatch_third,\n        ]\n        cnj_lifts = [\n            self.cnj_first,\n            self.cnj_second,\n            self.cnj_third,\n        ]\n        # must have at least a snatch lift and cnj to total\n        snatch_made = any([lift == \"LIFT\" for lift in snatch_lifts])\n        cnj_made = any([lift == \"LIFT\" for lift in cnj_lifts])\n        if all([snatch_made, cnj_made]):\n            total_lifted = self.best_snatch_weight[1] + self.best_cnj_weight[1]\n        return total_lifted\n\n    @property\n    def age_categories(self) -&gt; AgeCategories:\n\"\"\"Age category of the athlete at the time of the lift.\"\"\"\n        return age_category(\n            yearborn=self.athlete.yearborn,\n            competition_year=self.competition.date_start.year,\n        )\n\n    @property\n    def sinclair(self) -&gt; Decimal:\n\"\"\"Calculate sinclair for a lift.\"\"\"\n        return calculate_sinclair(\n            bodyweight=self.bodyweight,\n            total_lifted=self.total_lifted,\n            weight_category=self.weight_category,\n            yearborn=self.athlete.yearborn,\n            lift_year=self.competition.date_start.year,\n        )\n\n    @property\n    def grade(self) -&gt; str:\n\"\"\"Determine the grade of the lift.\"\"\"\n        return determine_grade(\n            total_lifted=self.total_lifted,\n            weight_category=self.weight_category,\n        )\n\n    @cached_property\n    # TODO: placings for junior, senior etc\n    def placing(self) -&gt; str:\n\"\"\"Determine placing of the athlete from weightclass.\n\n        How placing is determined in weightlifting:\n        1. Best total\n        - If totals are tied, then we need to determine who achieved the total\n        first.\n        2. Lowest clean and jerk\n        3. Least number of attempts\n        4. Lowest lottery number\n        \"\"\"\n        if self.total_lifted == 0:\n            return \"-\"\n        query = Lift.objects.filter(\n            competition=self.competition, weight_category=self.weight_category\n        )\n        lifts = [\n            {\n                \"reference_id\": q.reference_id,\n                \"best_cnj_weight\": q.best_cnj_weight,\n                \"total_lifted\": q.total_lifted,\n                \"lottery_number\": q.lottery_number,\n            }\n            for q in query\n            if q.total_lifted &gt; 0  # ensures sorted lifts have a total\n        ]\n        sorted_lifts = sorted(\n            lifts,\n            key=lambda x: (\n                -x[\"total_lifted\"],\n                x[\"best_cnj_weight\"][1],\n                x[\"best_cnj_weight\"][0],\n                x[\"lottery_number\"],\n            ),\n        )\n        sorted_lifts_ids = [lift[\"reference_id\"] for lift in sorted_lifts]\n        return ranking_suffixer(sorted_lifts_ids.index(self.reference_id) + 1)\n\n    def clean(self, *args, **kwargs):\n\"\"\"Customise validation.\n\n        0. Validation attempts to ensure they are increasing depending on the\n        current lift status.\n        1. Weightclasses are relevant to the date of the competition.\n        \"\"\"\n        errors = []\n        # 0. lift validation\n        errors.extend(\n            validate_attempts(attempts=self.snatches, lift_type=\"snatch\")\n        )\n        errors.extend(\n            validate_attempts(attempts=self.cnjs, lift_type=\"clean and jerk\")\n        )\n\n        # 1. Weightclass validation\n        # CATEGORY is list of tuples e.g. `[..., ('M102+', 'M102+'), ...]`\n        # if (\n        #     self.competition.date_start.year &gt;= 2018\n        #     and self.weight_category\n        #     not in (w[0] for w in CURRENT_WEIGHT_CATEGORIES)\n        # ) or (\n        #     self.competition.date_start.year &lt;= 2018\n        #     and self.weight_category\n        #     not in (w[0] for w in OLD_WEIGHT_CATEGORIES)\n        # ):\n        #     errors.append(\"Weightclass from wrong era.\")\n        if len(errors) &gt; 0:\n            error_msg = \"\\n\".join(errors)\n            raise ValidationError(\n                \"%(error_msg)s\",\n                code=\"Invalid Attempt\",\n                params={\n                    \"error_msg\": error_msg,\n                },\n            )\n\n        super().clean(*args, **kwargs)\n\n    def save(self, *args, **kwargs):\n\"\"\"Necessary to enact custom validation in `clean()` method.\"\"\"\n        self.full_clean()\n        super().save(*args, **kwargs)\n\n    def __str__(self):\n\"\"\"__str__.\"\"\"\n        return f\"{self.athlete} - {self.competition} {self.competition.date_start.year}\"\n</code></pre> <p>options: members: - placing</p>"},{"location":"placing/#api.models.lifts.Lift.age_categories","title":"<code>age_categories: AgeCategories</code>  <code>property</code>","text":"<p>Age category of the athlete at the time of the lift.</p>"},{"location":"placing/#api.models.lifts.Lift.best_cnj_weight","title":"<code>best_cnj_weight: tuple[str, int]</code>  <code>property</code>","text":"<p>Best clean and jerk returned.</p>"},{"location":"placing/#api.models.lifts.Lift.best_snatch_weight","title":"<code>best_snatch_weight: tuple[str, int]</code>  <code>property</code>","text":"<p>Best snatch weight returned.</p>"},{"location":"placing/#api.models.lifts.Lift.cnjs","title":"<code>cnjs: dict[str, LiftT]</code>  <code>property</code>","text":"<p>Clean and Jerk custom field.</p>"},{"location":"placing/#api.models.lifts.Lift.grade","title":"<code>grade: str</code>  <code>property</code>","text":"<p>Determine the grade of the lift.</p>"},{"location":"placing/#api.models.lifts.Lift.sinclair","title":"<code>sinclair: Decimal</code>  <code>property</code>","text":"<p>Calculate sinclair for a lift.</p>"},{"location":"placing/#api.models.lifts.Lift.snatches","title":"<code>snatches: dict[str, LiftT]</code>  <code>property</code>","text":"<p>Snatches custom field.</p>"},{"location":"placing/#api.models.lifts.Lift.total_lifted","title":"<code>total_lifted: int</code>  <code>property</code>","text":"<p>Calculate total.</p>"},{"location":"placing/#api.models.lifts.Lift.__str__","title":"<code>__str__()</code>","text":"<p>str.</p> Source code in <code>api/models/lifts.py</code> <pre><code>def __str__(self):\n\"\"\"__str__.\"\"\"\n    return f\"{self.athlete} - {self.competition} {self.competition.date_start.year}\"\n</code></pre>"},{"location":"placing/#api.models.lifts.Lift.clean","title":"<code>clean(*args, **kwargs)</code>","text":"<p>Customise validation.</p> <ol> <li>Validation attempts to ensure they are increasing depending on the current lift status.</li> <li>Weightclasses are relevant to the date of the competition.</li> </ol> Source code in <code>api/models/lifts.py</code> <pre><code>def clean(self, *args, **kwargs):\n\"\"\"Customise validation.\n\n    0. Validation attempts to ensure they are increasing depending on the\n    current lift status.\n    1. Weightclasses are relevant to the date of the competition.\n    \"\"\"\n    errors = []\n    # 0. lift validation\n    errors.extend(\n        validate_attempts(attempts=self.snatches, lift_type=\"snatch\")\n    )\n    errors.extend(\n        validate_attempts(attempts=self.cnjs, lift_type=\"clean and jerk\")\n    )\n\n    # 1. Weightclass validation\n    # CATEGORY is list of tuples e.g. `[..., ('M102+', 'M102+'), ...]`\n    # if (\n    #     self.competition.date_start.year &gt;= 2018\n    #     and self.weight_category\n    #     not in (w[0] for w in CURRENT_WEIGHT_CATEGORIES)\n    # ) or (\n    #     self.competition.date_start.year &lt;= 2018\n    #     and self.weight_category\n    #     not in (w[0] for w in OLD_WEIGHT_CATEGORIES)\n    # ):\n    #     errors.append(\"Weightclass from wrong era.\")\n    if len(errors) &gt; 0:\n        error_msg = \"\\n\".join(errors)\n        raise ValidationError(\n            \"%(error_msg)s\",\n            code=\"Invalid Attempt\",\n            params={\n                \"error_msg\": error_msg,\n            },\n        )\n\n    super().clean(*args, **kwargs)\n</code></pre>"},{"location":"placing/#api.models.lifts.Lift.placing","title":"<code>placing()</code>","text":"<p>Determine placing of the athlete from weightclass.</p> <p>How placing is determined in weightlifting: 1. Best total - If totals are tied, then we need to determine who achieved the total first. 2. Lowest clean and jerk 3. Least number of attempts 4. Lowest lottery number</p> Source code in <code>api/models/lifts.py</code> <pre><code>@cached_property\n# TODO: placings for junior, senior etc\ndef placing(self) -&gt; str:\n\"\"\"Determine placing of the athlete from weightclass.\n\n    How placing is determined in weightlifting:\n    1. Best total\n    - If totals are tied, then we need to determine who achieved the total\n    first.\n    2. Lowest clean and jerk\n    3. Least number of attempts\n    4. Lowest lottery number\n    \"\"\"\n    if self.total_lifted == 0:\n        return \"-\"\n    query = Lift.objects.filter(\n        competition=self.competition, weight_category=self.weight_category\n    )\n    lifts = [\n        {\n            \"reference_id\": q.reference_id,\n            \"best_cnj_weight\": q.best_cnj_weight,\n            \"total_lifted\": q.total_lifted,\n            \"lottery_number\": q.lottery_number,\n        }\n        for q in query\n        if q.total_lifted &gt; 0  # ensures sorted lifts have a total\n    ]\n    sorted_lifts = sorted(\n        lifts,\n        key=lambda x: (\n            -x[\"total_lifted\"],\n            x[\"best_cnj_weight\"][1],\n            x[\"best_cnj_weight\"][0],\n            x[\"lottery_number\"],\n        ),\n    )\n    sorted_lifts_ids = [lift[\"reference_id\"] for lift in sorted_lifts]\n    return ranking_suffixer(sorted_lifts_ids.index(self.reference_id) + 1)\n</code></pre>"},{"location":"placing/#api.models.lifts.Lift.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>Necessary to enact custom validation in <code>clean()</code> method.</p> Source code in <code>api/models/lifts.py</code> <pre><code>def save(self, *args, **kwargs):\n\"\"\"Necessary to enact custom validation in `clean()` method.\"\"\"\n    self.full_clean()\n    super().save(*args, **kwargs)\n</code></pre>"},{"location":"placing/#future","title":"Future","text":"<p>Looking into segragating Junior, Youth etc.</p>"}]}