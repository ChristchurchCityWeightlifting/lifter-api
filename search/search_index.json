{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lifter API Lifter API Documentation Did you mean Lifter API Wrapper Documentation ? Hosting This is hosted on Digital Ocean's App Platform . Code changes to this repository on the main branch will automatically trigger changes to the live web application. The backend API and the frontend are set up on their own apps. And there is set up required (see below). Normally, this is first time. Setting up the Backend 1. Run command This is the run command: gunicorn --worker-tmp-dir /dev/shm config.wsgi Note the config.wsgi 2. API Domain Ensure the domain provided this is set to: https://api.lifter.shivan.xyz . This may take time to configure. And this is all handled by Digital Ocean. 3. Backend Environment Variables The following environment variables should be set: DJANGO_DEVELOPMENT = 0 ALLOWED_HOSTS = ${APP_DOMAIN} DATABASE_URL = ${db.DATABASE_URL} CORS_ALLOWED_ORIGINS = https://lifter.shivan.xyz SECRET_KEY = <see below> HASHID_FIELD_SALT = <see below> SENTRY_DSN_1 = <see below> SENTRY_DSN_2 = <see below> SENTRY_SAMPLE_RATE = 1.0 # depends Secret Keys Running the below code will provide the a random hash to set SECRET_KEY and HASHID_FIELD_SALT . $ make generate-key ffqd6(a-&dqk#znv!4@!1u=&_et9b^wdgpm5cz4=^b=9_3xaux Tip: Use make generate-key | pbcopy on MacOS if you want to copy the key to clipboard. Sentry Environment Variables These are mapped accordingly: sentry_sdk.init( dsn=f\"https://{SENTRY_DSN_1}.ingest.sentry.io/{SENTRY_DSN_2}\", integrations=[ DjangoIntegration(), ], # set this to between 0 and 1.0 when in production trace_sample_rate=SENTRY_SAMPLE_RATE 4. Migrations and Superuser In the console of the Digital Ocean App Platform migrations and a creation of a superuser is required. Migration: python manage.py makemigrations python manage.py migrate Create superuser: python manage.py createsuperuser 5. Debugging There is a debug.log file provided. Use this command to follow the debug log in realtime: tail -f debug.log Setting up the Frontend 1. Catch-all Catch-all needs to be set to index.html . This is because react-router uses the url link to decide what content to serve, rather than a url requesting something on the server. That means a url other than the root url will return a 404 error. A catch-all will return the root url for processing by javascript. 2. Main Domain Another domain is provided. Ensure this is set to: https://lifter.shivan.xyz . This takes time and is all handled by Digital Ocean. 3. Frontend Environment Variables The environment variables need to be set: REACT_APP_API_URL = \"https://api.lifter.shivan.xyz/v1\" Local Development Base requirements include: Docker v20.10.8 Docker Compose v2.0.0 Node v16.14.2 Python v3.10.0 Here is the rough layout of the application: lifter-api \u251c\u2500\u2500 backend/ \u2502 \u251c\u2500\u2500 ... Django Rest Framework stuff \u251c\u2500\u2500 frontend \u2502 \u251c\u2500\u2500 ... React Typescript TailwindCSS stuff \u2514\u2500\u2500 ...other files The PostgreSQL database runs in a docker container and to start the API all you need to do is run: make run You might have to perform migrations: make migrations There is an API backend as well as a nice looking frontend layout. To run the frontend: make run-frontend Lifter API Wrapper Here is an API wrapper implementation to allow ease of use with the RESTful framework. It is also available on PyPI . You can easily install it: pip install lifter-api-wrapper","title":"Home"},{"location":"#lifter-api","text":"","title":"Lifter API"},{"location":"#lifter-api-documentation","text":"Did you mean Lifter API Wrapper Documentation ?","title":"Lifter API Documentation"},{"location":"#hosting","text":"This is hosted on Digital Ocean's App Platform . Code changes to this repository on the main branch will automatically trigger changes to the live web application. The backend API and the frontend are set up on their own apps. And there is set up required (see below). Normally, this is first time.","title":"Hosting"},{"location":"#setting-up-the-backend","text":"","title":"Setting up the Backend"},{"location":"#1-run-command","text":"This is the run command: gunicorn --worker-tmp-dir /dev/shm config.wsgi Note the config.wsgi","title":"1. Run command"},{"location":"#2-api-domain","text":"Ensure the domain provided this is set to: https://api.lifter.shivan.xyz . This may take time to configure. And this is all handled by Digital Ocean.","title":"2. API Domain"},{"location":"#3-backend-environment-variables","text":"The following environment variables should be set: DJANGO_DEVELOPMENT = 0 ALLOWED_HOSTS = ${APP_DOMAIN} DATABASE_URL = ${db.DATABASE_URL} CORS_ALLOWED_ORIGINS = https://lifter.shivan.xyz SECRET_KEY = <see below> HASHID_FIELD_SALT = <see below> SENTRY_DSN_1 = <see below> SENTRY_DSN_2 = <see below> SENTRY_SAMPLE_RATE = 1.0 # depends","title":"3. Backend Environment Variables"},{"location":"#secret-keys","text":"Running the below code will provide the a random hash to set SECRET_KEY and HASHID_FIELD_SALT . $ make generate-key ffqd6(a-&dqk#znv!4@!1u=&_et9b^wdgpm5cz4=^b=9_3xaux Tip: Use make generate-key | pbcopy on MacOS if you want to copy the key to clipboard.","title":"Secret Keys"},{"location":"#sentry-environment-variables","text":"These are mapped accordingly: sentry_sdk.init( dsn=f\"https://{SENTRY_DSN_1}.ingest.sentry.io/{SENTRY_DSN_2}\", integrations=[ DjangoIntegration(), ], # set this to between 0 and 1.0 when in production trace_sample_rate=SENTRY_SAMPLE_RATE","title":"Sentry Environment Variables"},{"location":"#4-migrations-and-superuser","text":"In the console of the Digital Ocean App Platform migrations and a creation of a superuser is required. Migration: python manage.py makemigrations python manage.py migrate Create superuser: python manage.py createsuperuser","title":"4. Migrations and Superuser"},{"location":"#5-debugging","text":"There is a debug.log file provided. Use this command to follow the debug log in realtime: tail -f debug.log","title":"5. Debugging"},{"location":"#setting-up-the-frontend","text":"","title":"Setting up the Frontend"},{"location":"#1-catch-all","text":"Catch-all needs to be set to index.html . This is because react-router uses the url link to decide what content to serve, rather than a url requesting something on the server. That means a url other than the root url will return a 404 error. A catch-all will return the root url for processing by javascript.","title":"1. Catch-all"},{"location":"#2-main-domain","text":"Another domain is provided. Ensure this is set to: https://lifter.shivan.xyz . This takes time and is all handled by Digital Ocean.","title":"2. Main Domain"},{"location":"#3-frontend-environment-variables","text":"The environment variables need to be set: REACT_APP_API_URL = \"https://api.lifter.shivan.xyz/v1\"","title":"3. Frontend Environment Variables"},{"location":"#local-development","text":"Base requirements include: Docker v20.10.8 Docker Compose v2.0.0 Node v16.14.2 Python v3.10.0 Here is the rough layout of the application: lifter-api \u251c\u2500\u2500 backend/ \u2502 \u251c\u2500\u2500 ... Django Rest Framework stuff \u251c\u2500\u2500 frontend \u2502 \u251c\u2500\u2500 ... React Typescript TailwindCSS stuff \u2514\u2500\u2500 ...other files The PostgreSQL database runs in a docker container and to start the API all you need to do is run: make run You might have to perform migrations: make migrations There is an API backend as well as a nice looking frontend layout. To run the frontend: make run-frontend","title":"Local Development"},{"location":"#lifter-api-wrapper","text":"Here is an API wrapper implementation to allow ease of use with the RESTful framework. It is also available on PyPI . You can easily install it: pip install lifter-api-wrapper","title":"Lifter API Wrapper"},{"location":"about/","text":"About The goal of Lifter API is to make Weightlifting Competition results more accessible. The origin story goes, we were tired of viewing competition results on .pdf and Excel files. It was also difficult to determine records, and gradings.","title":"About"},{"location":"about/#about","text":"The goal of Lifter API is to make Weightlifting Competition results more accessible. The origin story goes, we were tired of viewing competition results on .pdf and Excel files. It was also difficult to determine records, and gradings.","title":"About"},{"location":"grading/","text":"Grading How it works Grading is determined based on looking at a dictionary. The grade is applied to a lift. The athlete is awarded if they have achieved the total for the current year. This is represented as a badge. Determine grade for a lift. determine_grade ( total_lifted , weight_category ) Provide the grade for a particular lift. Parameters: Name Type Description Default total_lifted int The total lifted. required weight_category str The weight class for the athlete. required Returns: Type Description str The grade. Source code in api/models/utils/grading.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def determine_grade ( total_lifted : int , weight_category : str ) -> str : \"\"\"Provide the grade for a particular lift. Args: total_lifted (int): The total lifted. weight_category (str): The weight class for the athlete. Returns: (str): The grade. \"\"\" grades = STANDARDS . get ( weight_category ) if grades is not None : for k , v in grades . items (): if v is not None and total_lifted >= v : return k . title () return None Future The plan is to store the grades on a database, linking to weight catetory and setting a era in case they change from year to year.","title":"Grading"},{"location":"grading/#grading","text":"","title":"Grading"},{"location":"grading/#how-it-works","text":"Grading is determined based on looking at a dictionary. The grade is applied to a lift. The athlete is awarded if they have achieved the total for the current year. This is represented as a badge. Determine grade for a lift.","title":"How it works"},{"location":"grading/#api.models.utils.grading.determine_grade","text":"Provide the grade for a particular lift. Parameters: Name Type Description Default total_lifted int The total lifted. required weight_category str The weight class for the athlete. required Returns: Type Description str The grade. Source code in api/models/utils/grading.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 def determine_grade ( total_lifted : int , weight_category : str ) -> str : \"\"\"Provide the grade for a particular lift. Args: total_lifted (int): The total lifted. weight_category (str): The weight class for the athlete. Returns: (str): The grade. \"\"\" grades = STANDARDS . get ( weight_category ) if grades is not None : for k , v in grades . items (): if v is not None and total_lifted >= v : return k . title () return None","title":"determine_grade()"},{"location":"grading/#future","text":"The plan is to store the grades on a database, linking to weight catetory and setting a era in case they change from year to year.","title":"Future"},{"location":"how/","text":"How It Works Overview The API consists of three models: Athlete , Competition , and Lift Determining the Junior/Youth/Senior The API is able to determine if a athlete at the time of the competition date start if they are Youth, Junior and/or Senior. Design choices Female before Male ordering Generally, competitions lift with female first following by males. The subject of gender can be particularly sensitive. So a choice was made to detach gender from athletes, and instead Data Protection The only data available is the athlete's name, birth year (to determine age grading) and their competitions lifts. Grading Grading is determined by looking at the lifts for the current year and determining the best grade from these lifts. Roadmap Include volunteers on the competition results","title":"How it works"},{"location":"how/#how-it-works","text":"","title":"How It Works"},{"location":"how/#overview","text":"The API consists of three models: Athlete , Competition , and Lift","title":"Overview"},{"location":"how/#determining-the-junioryouthsenior","text":"The API is able to determine if a athlete at the time of the competition date start if they are Youth, Junior and/or Senior.","title":"Determining the Junior/Youth/Senior"},{"location":"how/#design-choices","text":"","title":"Design choices"},{"location":"how/#female-before-male-ordering","text":"Generally, competitions lift with female first following by males. The subject of gender can be particularly sensitive. So a choice was made to detach gender from athletes, and instead","title":"Female before Male ordering"},{"location":"how/#data-protection","text":"The only data available is the athlete's name, birth year (to determine age grading) and their competitions lifts.","title":"Data Protection"},{"location":"how/#grading","text":"Grading is determined by looking at the lifts for the current year and determining the best grade from these lifts.","title":"Grading"},{"location":"how/#roadmap","text":"Include volunteers on the competition results","title":"Roadmap"},{"location":"placing/","text":"Placing Determining placing (i.e. 1st, 2nd, 3rd) in weightlifting is handed by a property on the lift model. According to the IWF rules (pls find source), the athlete who achieves the highest total first in placed ahead. Essentially it is a sort of different values for athletes in a competition, filtering on category: Highest total Lowest clean and jerk Lowest lottery number. Bases: models . Model Lift model. Source code in api/models/lifts.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 class Lift ( models . Model ): \"\"\"Lift model.\"\"\" # key fields reference_id = HashidAutoField ( primary_key = True , salt = f \"liftmodel_reference_id_ { HASHID_FIELD_SALT } \" ) competition = models . ForeignKey ( \"api.Competition\" , on_delete = models . CASCADE ) athlete = models . ForeignKey ( \"api.Athlete\" , on_delete = models . CASCADE ) # other fields session_number = models . IntegerField ( null = True ) lottery_number = models . IntegerField ( blank = True ) bodyweight = models . DecimalField ( blank = True , max_digits = 5 , decimal_places = 2 ) weight_category = models . CharField ( max_length = 5 , choices = ALL_WEIGHT_CATEGORIES , blank = True ) # TODO: if `team` is \"GUEST\", then lifter is a guest team = models . CharField ( max_length = 128 , blank = True , default = \"IND\" ) # lifts fields # snatches snatch_first = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) snatch_first_weight = models . IntegerField ( blank = True , default = 0 ) snatch_second = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) snatch_second_weight = models . IntegerField ( blank = True , default = 0 ) snatch_third = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) snatch_third_weight = models . IntegerField ( blank = True , default = 0 ) # cnj cnj_first = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) cnj_first_weight = models . IntegerField ( blank = True , default = 0 ) cnj_second = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) cnj_second_weight = models . IntegerField ( blank = True , default = 0 ) cnj_third = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) cnj_third_weight = models . IntegerField ( blank = True , default = 0 ) objects = LiftManager () class Meta : ordering = [ \"weight_category\" , \"lottery_number\" ] constraints = [ models . UniqueConstraint ( fields = [ \"competition\" , \"lottery_number\" , \"weight_category\" ], name = \"session_lottery_unique_combination\" , ), models . UniqueConstraint ( fields = [ \"competition\" , \"athlete\" ], name = \"competition_athlete_unique_combination\" , ), ] # # custom fields # # lifts # @property def snatches ( self ) -> dict [ str , LiftT ]: \"\"\"Snatches custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . snatch_first , \"weight\" : self . snatch_first_weight , }, \"2nd\" : { \"lift_status\" : self . snatch_second , \"weight\" : self . snatch_second_weight , }, \"3rd\" : { \"lift_status\" : self . snatch_third , \"weight\" : self . snatch_third_weight , }, } # @property # def new_snatch_first(self) -> int | None: # if self.snatch_first == \"DNA\": # return None # elif self.snatch_first == \"NOLIFT\": # return -1 * abs(self.snatch_first_weight) # elif self.snatch_first == \"LIFT\": # return abs(self.snatch_first_weight) @property def cnjs ( self ) -> dict [ str , LiftT ]: \"\"\"Clean and Jerk custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . cnj_first , \"weight\" : self . cnj_first_weight , }, \"2nd\" : { \"lift_status\" : self . cnj_second , \"weight\" : self . cnj_second_weight , }, \"3rd\" : { \"lift_status\" : self . cnj_third , \"weight\" : self . cnj_third_weight , }, } @property def best_snatch_weight ( self ) -> tuple [ str , int ]: \"\"\"Best snatch weight returned.\"\"\" return best_lift ( self . snatches ) @property def best_cnj_weight ( self ) -> tuple [ str , int ]: \"\"\"Best clean and jerk returned.\"\"\" return best_lift ( self . cnjs ) @property def total_lifted ( self ) -> int : \"\"\"Calculate total.\"\"\" total_lifted = 0 snatch_lifts = [ self . snatch_first , self . snatch_second , self . snatch_third , ] cnj_lifts = [ self . cnj_first , self . cnj_second , self . cnj_third , ] # must have at least a snatch lift and cnj to total snatch_made = any ([ lift == \"LIFT\" for lift in snatch_lifts ]) cnj_made = any ([ lift == \"LIFT\" for lift in cnj_lifts ]) if all ([ snatch_made , cnj_made ]): total_lifted = self . best_snatch_weight [ 1 ] + self . best_cnj_weight [ 1 ] return total_lifted @property def age_categories ( self ) -> AgeCategories : \"\"\"Age category of the athlete at the time of the lift.\"\"\" return age_category ( yearborn = self . athlete . yearborn , competition_year = self . competition . date_start . year , ) @property def sinclair ( self ) -> Decimal : \"\"\"Calculate sinclair for a lift.\"\"\" return calculate_sinclair ( bodyweight = self . bodyweight , total_lifted = self . total_lifted , weight_category = self . weight_category , yearborn = self . athlete . yearborn , lift_year = self . competition . date_start . year , ) @property def grade ( self ) -> str : \"\"\"Determine the grade of the lift.\"\"\" return determine_grade ( total_lifted = self . total_lifted , weight_category = self . weight_category , ) @cached_property # TODO: placings for junior, senior etc def placing ( self ) -> str : \"\"\"Determine placing of the athlete from weightclass. How placing is determined in weightlifting: 1. Best total - If totals are tied, then we need to determine who achieved the total first. 2. Lowest clean and jerk 3. Least number of attempts 4. Lowest lottery number \"\"\" if self . total_lifted == 0 : return \"-\" query = Lift . objects . filter ( competition = self . competition , weight_category = self . weight_category ) lifts = [ { \"reference_id\" : q . reference_id , \"best_cnj_weight\" : q . best_cnj_weight , \"total_lifted\" : q . total_lifted , \"lottery_number\" : q . lottery_number , } for q in query if q . total_lifted > 0 # ensures sorted lifts have a total ] sorted_lifts = sorted ( lifts , key = lambda x : ( - x [ \"total_lifted\" ], x [ \"best_cnj_weight\" ][ 1 ], x [ \"best_cnj_weight\" ][ 0 ], x [ \"lottery_number\" ], ), ) sorted_lifts_ids = [ lift [ \"reference_id\" ] for lift in sorted_lifts ] return ranking_suffixer ( sorted_lifts_ids . index ( self . reference_id ) + 1 ) def clean ( self , * args , ** kwargs ): \"\"\"Customise validation. 0. Validation attempts to ensure they are increasing depending on the current lift status. 1. Weightclasses are relevant to the date of the competition. \"\"\" errors = [] # 0. lift validation errors . extend ( validate_attempts ( attempts = self . snatches , lift_type = \"snatch\" ) ) errors . extend ( validate_attempts ( attempts = self . cnjs , lift_type = \"clean and jerk\" ) ) # 1. Weightclass validation # CATEGORY is list of tuples e.g. `[..., ('M102+', 'M102+'), ...]` # if ( # self.competition.date_start.year >= 2018 # and self.weight_category # not in (w[0] for w in CURRENT_WEIGHT_CATEGORIES) # ) or ( # self.competition.date_start.year <= 2018 # and self.weight_category # not in (w[0] for w in OLD_WEIGHT_CATEGORIES) # ): # errors.append(\"Weightclass from wrong era.\") if len ( errors ) > 0 : error_msg = \" \\n \" . join ( errors ) raise ValidationError ( \" %(error_msg)s \" , code = \"Invalid Attempt\" , params = { \"error_msg\" : error_msg , }, ) super () . clean ( * args , ** kwargs ) def save ( self , * args , ** kwargs ): \"\"\"Necessary to enact custom validation in `clean()` method.\"\"\" self . full_clean () super () . save ( * args , ** kwargs ) def __str__ ( self ): \"\"\"__str__.\"\"\" return f \" { self . athlete } - { self . competition } { self . competition . date_start . year } \" __str__ () str . Source code in api/models/lifts.py 349 350 351 def __str__ ( self ): \"\"\"__str__.\"\"\" return f \" { self . athlete } - { self . competition } { self . competition . date_start . year } \" age_categories () property Age category of the athlete at the time of the lift. Source code in api/models/lifts.py 237 238 239 240 241 242 243 @property def age_categories ( self ) -> AgeCategories : \"\"\"Age category of the athlete at the time of the lift.\"\"\" return age_category ( yearborn = self . athlete . yearborn , competition_year = self . competition . date_start . year , ) best_cnj_weight () property Best clean and jerk returned. Source code in api/models/lifts.py 211 212 213 214 @property def best_cnj_weight ( self ) -> tuple [ str , int ]: \"\"\"Best clean and jerk returned.\"\"\" return best_lift ( self . cnjs ) best_snatch_weight () property Best snatch weight returned. Source code in api/models/lifts.py 206 207 208 209 @property def best_snatch_weight ( self ) -> tuple [ str , int ]: \"\"\"Best snatch weight returned.\"\"\" return best_lift ( self . snatches ) clean ( * args , ** kwargs ) Customise validation. Validation attempts to ensure they are increasing depending on the current lift status. Weightclasses are relevant to the date of the competition. Source code in api/models/lifts.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def clean ( self , * args , ** kwargs ): \"\"\"Customise validation. 0. Validation attempts to ensure they are increasing depending on the current lift status. 1. Weightclasses are relevant to the date of the competition. \"\"\" errors = [] # 0. lift validation errors . extend ( validate_attempts ( attempts = self . snatches , lift_type = \"snatch\" ) ) errors . extend ( validate_attempts ( attempts = self . cnjs , lift_type = \"clean and jerk\" ) ) # 1. Weightclass validation # CATEGORY is list of tuples e.g. `[..., ('M102+', 'M102+'), ...]` # if ( # self.competition.date_start.year >= 2018 # and self.weight_category # not in (w[0] for w in CURRENT_WEIGHT_CATEGORIES) # ) or ( # self.competition.date_start.year <= 2018 # and self.weight_category # not in (w[0] for w in OLD_WEIGHT_CATEGORIES) # ): # errors.append(\"Weightclass from wrong era.\") if len ( errors ) > 0 : error_msg = \" \\n \" . join ( errors ) raise ValidationError ( \" %(error_msg)s \" , code = \"Invalid Attempt\" , params = { \"error_msg\" : error_msg , }, ) super () . clean ( * args , ** kwargs ) cnjs () property Clean and Jerk custom field. Source code in api/models/lifts.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @property def cnjs ( self ) -> dict [ str , LiftT ]: \"\"\"Clean and Jerk custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . cnj_first , \"weight\" : self . cnj_first_weight , }, \"2nd\" : { \"lift_status\" : self . cnj_second , \"weight\" : self . cnj_second_weight , }, \"3rd\" : { \"lift_status\" : self . cnj_third , \"weight\" : self . cnj_third_weight , }, } grade () property Determine the grade of the lift. Source code in api/models/lifts.py 256 257 258 259 260 261 262 @property def grade ( self ) -> str : \"\"\"Determine the grade of the lift.\"\"\" return determine_grade ( total_lifted = self . total_lifted , weight_category = self . weight_category , ) placing () Determine placing of the athlete from weightclass. How placing is determined in weightlifting: 1. Best total - If totals are tied, then we need to determine who achieved the total first. 2. Lowest clean and jerk 3. Least number of attempts 4. Lowest lottery number Source code in api/models/lifts.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 @cached_property # TODO: placings for junior, senior etc def placing ( self ) -> str : \"\"\"Determine placing of the athlete from weightclass. How placing is determined in weightlifting: 1. Best total - If totals are tied, then we need to determine who achieved the total first. 2. Lowest clean and jerk 3. Least number of attempts 4. Lowest lottery number \"\"\" if self . total_lifted == 0 : return \"-\" query = Lift . objects . filter ( competition = self . competition , weight_category = self . weight_category ) lifts = [ { \"reference_id\" : q . reference_id , \"best_cnj_weight\" : q . best_cnj_weight , \"total_lifted\" : q . total_lifted , \"lottery_number\" : q . lottery_number , } for q in query if q . total_lifted > 0 # ensures sorted lifts have a total ] sorted_lifts = sorted ( lifts , key = lambda x : ( - x [ \"total_lifted\" ], x [ \"best_cnj_weight\" ][ 1 ], x [ \"best_cnj_weight\" ][ 0 ], x [ \"lottery_number\" ], ), ) sorted_lifts_ids = [ lift [ \"reference_id\" ] for lift in sorted_lifts ] return ranking_suffixer ( sorted_lifts_ids . index ( self . reference_id ) + 1 ) save ( * args , ** kwargs ) Necessary to enact custom validation in clean() method. Source code in api/models/lifts.py 344 345 346 347 def save ( self , * args , ** kwargs ): \"\"\"Necessary to enact custom validation in `clean()` method.\"\"\" self . full_clean () super () . save ( * args , ** kwargs ) sinclair () property Calculate sinclair for a lift. Source code in api/models/lifts.py 245 246 247 248 249 250 251 252 253 254 @property def sinclair ( self ) -> Decimal : \"\"\"Calculate sinclair for a lift.\"\"\" return calculate_sinclair ( bodyweight = self . bodyweight , total_lifted = self . total_lifted , weight_category = self . weight_category , yearborn = self . athlete . yearborn , lift_year = self . competition . date_start . year , ) snatches () property Snatches custom field. Source code in api/models/lifts.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @property def snatches ( self ) -> dict [ str , LiftT ]: \"\"\"Snatches custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . snatch_first , \"weight\" : self . snatch_first_weight , }, \"2nd\" : { \"lift_status\" : self . snatch_second , \"weight\" : self . snatch_second_weight , }, \"3rd\" : { \"lift_status\" : self . snatch_third , \"weight\" : self . snatch_third_weight , }, } total_lifted () property Calculate total. Source code in api/models/lifts.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @property def total_lifted ( self ) -> int : \"\"\"Calculate total.\"\"\" total_lifted = 0 snatch_lifts = [ self . snatch_first , self . snatch_second , self . snatch_third , ] cnj_lifts = [ self . cnj_first , self . cnj_second , self . cnj_third , ] # must have at least a snatch lift and cnj to total snatch_made = any ([ lift == \"LIFT\" for lift in snatch_lifts ]) cnj_made = any ([ lift == \"LIFT\" for lift in cnj_lifts ]) if all ([ snatch_made , cnj_made ]): total_lifted = self . best_snatch_weight [ 1 ] + self . best_cnj_weight [ 1 ] return total_lifted options: members: - placing Future Looking into segragating Junior, Youth etc.","title":"Placing"},{"location":"placing/#placing","text":"Determining placing (i.e. 1st, 2nd, 3rd) in weightlifting is handed by a property on the lift model. According to the IWF rules (pls find source), the athlete who achieves the highest total first in placed ahead. Essentially it is a sort of different values for athletes in a competition, filtering on category: Highest total Lowest clean and jerk Lowest lottery number. Bases: models . Model Lift model. Source code in api/models/lifts.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 class Lift ( models . Model ): \"\"\"Lift model.\"\"\" # key fields reference_id = HashidAutoField ( primary_key = True , salt = f \"liftmodel_reference_id_ { HASHID_FIELD_SALT } \" ) competition = models . ForeignKey ( \"api.Competition\" , on_delete = models . CASCADE ) athlete = models . ForeignKey ( \"api.Athlete\" , on_delete = models . CASCADE ) # other fields session_number = models . IntegerField ( null = True ) lottery_number = models . IntegerField ( blank = True ) bodyweight = models . DecimalField ( blank = True , max_digits = 5 , decimal_places = 2 ) weight_category = models . CharField ( max_length = 5 , choices = ALL_WEIGHT_CATEGORIES , blank = True ) # TODO: if `team` is \"GUEST\", then lifter is a guest team = models . CharField ( max_length = 128 , blank = True , default = \"IND\" ) # lifts fields # snatches snatch_first = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) snatch_first_weight = models . IntegerField ( blank = True , default = 0 ) snatch_second = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) snatch_second_weight = models . IntegerField ( blank = True , default = 0 ) snatch_third = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) snatch_third_weight = models . IntegerField ( blank = True , default = 0 ) # cnj cnj_first = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) cnj_first_weight = models . IntegerField ( blank = True , default = 0 ) cnj_second = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) cnj_second_weight = models . IntegerField ( blank = True , default = 0 ) cnj_third = models . CharField ( max_length = 6 , choices = LIFT_STATUS , blank = True , default = DEFAULT_LIFT_STATUS , ) cnj_third_weight = models . IntegerField ( blank = True , default = 0 ) objects = LiftManager () class Meta : ordering = [ \"weight_category\" , \"lottery_number\" ] constraints = [ models . UniqueConstraint ( fields = [ \"competition\" , \"lottery_number\" , \"weight_category\" ], name = \"session_lottery_unique_combination\" , ), models . UniqueConstraint ( fields = [ \"competition\" , \"athlete\" ], name = \"competition_athlete_unique_combination\" , ), ] # # custom fields # # lifts # @property def snatches ( self ) -> dict [ str , LiftT ]: \"\"\"Snatches custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . snatch_first , \"weight\" : self . snatch_first_weight , }, \"2nd\" : { \"lift_status\" : self . snatch_second , \"weight\" : self . snatch_second_weight , }, \"3rd\" : { \"lift_status\" : self . snatch_third , \"weight\" : self . snatch_third_weight , }, } # @property # def new_snatch_first(self) -> int | None: # if self.snatch_first == \"DNA\": # return None # elif self.snatch_first == \"NOLIFT\": # return -1 * abs(self.snatch_first_weight) # elif self.snatch_first == \"LIFT\": # return abs(self.snatch_first_weight) @property def cnjs ( self ) -> dict [ str , LiftT ]: \"\"\"Clean and Jerk custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . cnj_first , \"weight\" : self . cnj_first_weight , }, \"2nd\" : { \"lift_status\" : self . cnj_second , \"weight\" : self . cnj_second_weight , }, \"3rd\" : { \"lift_status\" : self . cnj_third , \"weight\" : self . cnj_third_weight , }, } @property def best_snatch_weight ( self ) -> tuple [ str , int ]: \"\"\"Best snatch weight returned.\"\"\" return best_lift ( self . snatches ) @property def best_cnj_weight ( self ) -> tuple [ str , int ]: \"\"\"Best clean and jerk returned.\"\"\" return best_lift ( self . cnjs ) @property def total_lifted ( self ) -> int : \"\"\"Calculate total.\"\"\" total_lifted = 0 snatch_lifts = [ self . snatch_first , self . snatch_second , self . snatch_third , ] cnj_lifts = [ self . cnj_first , self . cnj_second , self . cnj_third , ] # must have at least a snatch lift and cnj to total snatch_made = any ([ lift == \"LIFT\" for lift in snatch_lifts ]) cnj_made = any ([ lift == \"LIFT\" for lift in cnj_lifts ]) if all ([ snatch_made , cnj_made ]): total_lifted = self . best_snatch_weight [ 1 ] + self . best_cnj_weight [ 1 ] return total_lifted @property def age_categories ( self ) -> AgeCategories : \"\"\"Age category of the athlete at the time of the lift.\"\"\" return age_category ( yearborn = self . athlete . yearborn , competition_year = self . competition . date_start . year , ) @property def sinclair ( self ) -> Decimal : \"\"\"Calculate sinclair for a lift.\"\"\" return calculate_sinclair ( bodyweight = self . bodyweight , total_lifted = self . total_lifted , weight_category = self . weight_category , yearborn = self . athlete . yearborn , lift_year = self . competition . date_start . year , ) @property def grade ( self ) -> str : \"\"\"Determine the grade of the lift.\"\"\" return determine_grade ( total_lifted = self . total_lifted , weight_category = self . weight_category , ) @cached_property # TODO: placings for junior, senior etc def placing ( self ) -> str : \"\"\"Determine placing of the athlete from weightclass. How placing is determined in weightlifting: 1. Best total - If totals are tied, then we need to determine who achieved the total first. 2. Lowest clean and jerk 3. Least number of attempts 4. Lowest lottery number \"\"\" if self . total_lifted == 0 : return \"-\" query = Lift . objects . filter ( competition = self . competition , weight_category = self . weight_category ) lifts = [ { \"reference_id\" : q . reference_id , \"best_cnj_weight\" : q . best_cnj_weight , \"total_lifted\" : q . total_lifted , \"lottery_number\" : q . lottery_number , } for q in query if q . total_lifted > 0 # ensures sorted lifts have a total ] sorted_lifts = sorted ( lifts , key = lambda x : ( - x [ \"total_lifted\" ], x [ \"best_cnj_weight\" ][ 1 ], x [ \"best_cnj_weight\" ][ 0 ], x [ \"lottery_number\" ], ), ) sorted_lifts_ids = [ lift [ \"reference_id\" ] for lift in sorted_lifts ] return ranking_suffixer ( sorted_lifts_ids . index ( self . reference_id ) + 1 ) def clean ( self , * args , ** kwargs ): \"\"\"Customise validation. 0. Validation attempts to ensure they are increasing depending on the current lift status. 1. Weightclasses are relevant to the date of the competition. \"\"\" errors = [] # 0. lift validation errors . extend ( validate_attempts ( attempts = self . snatches , lift_type = \"snatch\" ) ) errors . extend ( validate_attempts ( attempts = self . cnjs , lift_type = \"clean and jerk\" ) ) # 1. Weightclass validation # CATEGORY is list of tuples e.g. `[..., ('M102+', 'M102+'), ...]` # if ( # self.competition.date_start.year >= 2018 # and self.weight_category # not in (w[0] for w in CURRENT_WEIGHT_CATEGORIES) # ) or ( # self.competition.date_start.year <= 2018 # and self.weight_category # not in (w[0] for w in OLD_WEIGHT_CATEGORIES) # ): # errors.append(\"Weightclass from wrong era.\") if len ( errors ) > 0 : error_msg = \" \\n \" . join ( errors ) raise ValidationError ( \" %(error_msg)s \" , code = \"Invalid Attempt\" , params = { \"error_msg\" : error_msg , }, ) super () . clean ( * args , ** kwargs ) def save ( self , * args , ** kwargs ): \"\"\"Necessary to enact custom validation in `clean()` method.\"\"\" self . full_clean () super () . save ( * args , ** kwargs ) def __str__ ( self ): \"\"\"__str__.\"\"\" return f \" { self . athlete } - { self . competition } { self . competition . date_start . year } \"","title":"Placing"},{"location":"placing/#api.models.lifts.Lift.__str__","text":"str . Source code in api/models/lifts.py 349 350 351 def __str__ ( self ): \"\"\"__str__.\"\"\" return f \" { self . athlete } - { self . competition } { self . competition . date_start . year } \"","title":"__str__()"},{"location":"placing/#api.models.lifts.Lift.age_categories","text":"Age category of the athlete at the time of the lift. Source code in api/models/lifts.py 237 238 239 240 241 242 243 @property def age_categories ( self ) -> AgeCategories : \"\"\"Age category of the athlete at the time of the lift.\"\"\" return age_category ( yearborn = self . athlete . yearborn , competition_year = self . competition . date_start . year , )","title":"age_categories()"},{"location":"placing/#api.models.lifts.Lift.best_cnj_weight","text":"Best clean and jerk returned. Source code in api/models/lifts.py 211 212 213 214 @property def best_cnj_weight ( self ) -> tuple [ str , int ]: \"\"\"Best clean and jerk returned.\"\"\" return best_lift ( self . cnjs )","title":"best_cnj_weight()"},{"location":"placing/#api.models.lifts.Lift.best_snatch_weight","text":"Best snatch weight returned. Source code in api/models/lifts.py 206 207 208 209 @property def best_snatch_weight ( self ) -> tuple [ str , int ]: \"\"\"Best snatch weight returned.\"\"\" return best_lift ( self . snatches )","title":"best_snatch_weight()"},{"location":"placing/#api.models.lifts.Lift.clean","text":"Customise validation. Validation attempts to ensure they are increasing depending on the current lift status. Weightclasses are relevant to the date of the competition. Source code in api/models/lifts.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def clean ( self , * args , ** kwargs ): \"\"\"Customise validation. 0. Validation attempts to ensure they are increasing depending on the current lift status. 1. Weightclasses are relevant to the date of the competition. \"\"\" errors = [] # 0. lift validation errors . extend ( validate_attempts ( attempts = self . snatches , lift_type = \"snatch\" ) ) errors . extend ( validate_attempts ( attempts = self . cnjs , lift_type = \"clean and jerk\" ) ) # 1. Weightclass validation # CATEGORY is list of tuples e.g. `[..., ('M102+', 'M102+'), ...]` # if ( # self.competition.date_start.year >= 2018 # and self.weight_category # not in (w[0] for w in CURRENT_WEIGHT_CATEGORIES) # ) or ( # self.competition.date_start.year <= 2018 # and self.weight_category # not in (w[0] for w in OLD_WEIGHT_CATEGORIES) # ): # errors.append(\"Weightclass from wrong era.\") if len ( errors ) > 0 : error_msg = \" \\n \" . join ( errors ) raise ValidationError ( \" %(error_msg)s \" , code = \"Invalid Attempt\" , params = { \"error_msg\" : error_msg , }, ) super () . clean ( * args , ** kwargs )","title":"clean()"},{"location":"placing/#api.models.lifts.Lift.cnjs","text":"Clean and Jerk custom field. Source code in api/models/lifts.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 @property def cnjs ( self ) -> dict [ str , LiftT ]: \"\"\"Clean and Jerk custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . cnj_first , \"weight\" : self . cnj_first_weight , }, \"2nd\" : { \"lift_status\" : self . cnj_second , \"weight\" : self . cnj_second_weight , }, \"3rd\" : { \"lift_status\" : self . cnj_third , \"weight\" : self . cnj_third_weight , }, }","title":"cnjs()"},{"location":"placing/#api.models.lifts.Lift.grade","text":"Determine the grade of the lift. Source code in api/models/lifts.py 256 257 258 259 260 261 262 @property def grade ( self ) -> str : \"\"\"Determine the grade of the lift.\"\"\" return determine_grade ( total_lifted = self . total_lifted , weight_category = self . weight_category , )","title":"grade()"},{"location":"placing/#api.models.lifts.Lift.placing","text":"Determine placing of the athlete from weightclass. How placing is determined in weightlifting: 1. Best total - If totals are tied, then we need to determine who achieved the total first. 2. Lowest clean and jerk 3. Least number of attempts 4. Lowest lottery number Source code in api/models/lifts.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 @cached_property # TODO: placings for junior, senior etc def placing ( self ) -> str : \"\"\"Determine placing of the athlete from weightclass. How placing is determined in weightlifting: 1. Best total - If totals are tied, then we need to determine who achieved the total first. 2. Lowest clean and jerk 3. Least number of attempts 4. Lowest lottery number \"\"\" if self . total_lifted == 0 : return \"-\" query = Lift . objects . filter ( competition = self . competition , weight_category = self . weight_category ) lifts = [ { \"reference_id\" : q . reference_id , \"best_cnj_weight\" : q . best_cnj_weight , \"total_lifted\" : q . total_lifted , \"lottery_number\" : q . lottery_number , } for q in query if q . total_lifted > 0 # ensures sorted lifts have a total ] sorted_lifts = sorted ( lifts , key = lambda x : ( - x [ \"total_lifted\" ], x [ \"best_cnj_weight\" ][ 1 ], x [ \"best_cnj_weight\" ][ 0 ], x [ \"lottery_number\" ], ), ) sorted_lifts_ids = [ lift [ \"reference_id\" ] for lift in sorted_lifts ] return ranking_suffixer ( sorted_lifts_ids . index ( self . reference_id ) + 1 )","title":"placing()"},{"location":"placing/#api.models.lifts.Lift.save","text":"Necessary to enact custom validation in clean() method. Source code in api/models/lifts.py 344 345 346 347 def save ( self , * args , ** kwargs ): \"\"\"Necessary to enact custom validation in `clean()` method.\"\"\" self . full_clean () super () . save ( * args , ** kwargs )","title":"save()"},{"location":"placing/#api.models.lifts.Lift.sinclair","text":"Calculate sinclair for a lift. Source code in api/models/lifts.py 245 246 247 248 249 250 251 252 253 254 @property def sinclair ( self ) -> Decimal : \"\"\"Calculate sinclair for a lift.\"\"\" return calculate_sinclair ( bodyweight = self . bodyweight , total_lifted = self . total_lifted , weight_category = self . weight_category , yearborn = self . athlete . yearborn , lift_year = self . competition . date_start . year , )","title":"sinclair()"},{"location":"placing/#api.models.lifts.Lift.snatches","text":"Snatches custom field. Source code in api/models/lifts.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 @property def snatches ( self ) -> dict [ str , LiftT ]: \"\"\"Snatches custom field.\"\"\" return { \"1st\" : { \"lift_status\" : self . snatch_first , \"weight\" : self . snatch_first_weight , }, \"2nd\" : { \"lift_status\" : self . snatch_second , \"weight\" : self . snatch_second_weight , }, \"3rd\" : { \"lift_status\" : self . snatch_third , \"weight\" : self . snatch_third_weight , }, }","title":"snatches()"},{"location":"placing/#api.models.lifts.Lift.total_lifted","text":"Calculate total. Source code in api/models/lifts.py 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @property def total_lifted ( self ) -> int : \"\"\"Calculate total.\"\"\" total_lifted = 0 snatch_lifts = [ self . snatch_first , self . snatch_second , self . snatch_third , ] cnj_lifts = [ self . cnj_first , self . cnj_second , self . cnj_third , ] # must have at least a snatch lift and cnj to total snatch_made = any ([ lift == \"LIFT\" for lift in snatch_lifts ]) cnj_made = any ([ lift == \"LIFT\" for lift in cnj_lifts ]) if all ([ snatch_made , cnj_made ]): total_lifted = self . best_snatch_weight [ 1 ] + self . best_cnj_weight [ 1 ] return total_lifted options: members: - placing","title":"total_lifted()"},{"location":"placing/#future","text":"Looking into segragating Junior, Youth etc.","title":"Future"},{"location":"weight_categories/","text":"","title":"Weight Categories"}]}